# Arr + Gluetun Reference Layouts

[← Back to README](../README.md)

Use these Compose examples to deploy qBittorrent together with Prowlarr, Sonarr, Radarr, and Lidarr while keeping traffic inside Gluetun when required. The layouts mirror the stack generated by `arr.sh`, rely on Docker DNS (service names), and keep downloader/library paths anchored under the same `${ARR_DATA_ROOT}` tree so Arr apps and qBittorrent see identical locations.

## Shared conventions

- **Volumes:** The installer mounts `${DOWNLOADS_DIR}` and `${COMPLETED_DIR}` into qBittorrent and every Arr container. Keep both under the same `${ARR_DATA_ROOT}` prefix (defaults to `${HOME}/srv`) so completed downloads live at the same absolute path (for example `${ARR_DATA_ROOT}/downloads` with `${COMPLETED_DIR}` set to `${DOWNLOADS_DIR}/completed`). Hardlinks and instant moves only work when every service shares that tree (see [TRaSH qBittorrent Paths](https://trash-guides.info/Downloaders/qBittorrent/Paths/)). Use Remote Path Mapping only as a last resort.
- **IDs:** Set `PUID`/`PGID` to match the host user owning `${ARR_DATA_ROOT}`. Adjust file modes on the host so that user can create files (e.g., `sudo chown -R 1000:1000 ${ARR_DATA_ROOT}`).
- **Credentials:** The stack populates `QBT_USER`/`QBT_PASS` and binds the WebUI using `QBT_BIND_ADDR=0.0.0.0` (unless overridden by `QBT_ENFORCE_WEBUI`). Reuse those credentials in every Arr app download-client entry.
- **Health checks:** Gluetun must report healthy before qBittorrent starts, and qBittorrent must report healthy before Arr apps auto-test connectivity. The generated Compose uses `depends_on: condition: service_healthy` to enforce that ordering.

### Proton port forwarding essentials
- Proton issues an inbound port only when your **OpenVPN** username includes `+pmp`. arrbash appends the suffix just before launching Gluetun, so keep the stored credential without it.
- Proton’s WireGuard NAT-PMP flow is not yet supported here. Stick with Proton’s OpenVPN credentials (with `+pmp`) to guarantee the forwardable port arrbash expects.
- Gluetun records the leased port in `/tmp/gluetun/forwarded_port` and mirrors it over the control server at `http://127.0.0.1:${GLUETUN_CONTROL_PORT}/v1/openvpn/portforwarded`. arrbash bind-mounts `${ARR_DOCKER_DIR}/gluetun/state` into dependent containers so both the NAT-PMP lease file and the controller status JSON live there.
- Only Gluetun publishes ports to the LAN. qBittorrent and optional helpers share Gluetun’s namespace using `network_mode: "service:gluetun"`, so torrent traffic never bypasses the VPN.
- The control server binds to `127.0.0.1:${GLUETUN_CONTROL_PORT}`, requires `GLUETUN_API_KEY`, and exposes only basic status/port routes. Never map it to the LAN.
- `vpn-port-guard` now ships with the stack. It keeps qBittorrent paused until the VPN is healthy, applies the Proton lease via the Web API, and writes `pf_enabled` / `qbt_status` into `port-guard-status.json`. Torrents keep running without a leased port unless you opt into strict mode with `CONTROLLER_REQUIRE_PORT_FORWARDING=true`. See [vpn-port-guard](./vpn-port-guard.md) for lifecycle details.

## A) Split-mode ON (`SPLIT_VPN=1`, Arr apps on LAN)

```yaml
version: "3.8"

services:
  gluetun:
    image: ${GLUETUN_IMAGE}
    container_name: gluetun
    profiles:
      - "ipdirect"
    networks:
      - arr_net
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    environment:
      VPN_SERVICE_PROVIDER: "${VPN_SERVICE_PROVIDER}"
      VPN_TYPE: "${VPN_TYPE}"
      GLUETUN_FIREWALL_INPUT_PORTS: "${GLUETUN_FIREWALL_INPUT_PORTS}"   # VPN provider lease (NOT Docker ports)
      GLUETUN_FIREWALL_OUTBOUND_SUBNETS: "${GLUETUN_FIREWALL_OUTBOUND_SUBNETS}"
      HTTP_CONTROL_SERVER_ADDRESS: ":${GLUETUN_CONTROL_PORT}"
      HTTP_CONTROL_SERVER_AUTH: "apikey"
      HTTP_CONTROL_SERVER_APIKEY: "${GLUETUN_API_KEY}"
      VPN_PORT_FORWARDING: "on"
      VPN_PORT_FORWARDING_PROVIDER: "protonvpn"
      VPN_PORT_FORWARDING_STATUS_FILE: "/tmp/gluetun/forwarded_port"
      VPN_PORT_FORWARDING_UP_COMMAND: "/scripts/vpn-port-guard-hook.sh up"
      VPN_PORT_FORWARDING_DOWN_COMMAND: "/scripts/vpn-port-guard-hook.sh down"
      QBT_USER: "${QBT_USER}"
      QBT_PASS: "${QBT_PASS}"
      QBITTORRENT_ADDR: "http://${LOCALHOST_IP}:${QBT_INT_PORT}"
      TZ: "${TIMEZONE}"
      volumes:
        - "${ARR_DOCKER_DIR}/gluetun:/gluetun"
        - "gluetun_state:/tmp/gluetun"
        - "gluetun_state:/gluetun_state"
        - "${ARR_STACK_DIR}/scripts:/scripts:ro"
    ports:
      - "127.0.0.1:${GLUETUN_CONTROL_PORT}:${GLUETUN_CONTROL_PORT}"
      - "${LAN_IP}:${QBT_PORT}:${QBT_INT_PORT}"   # split-mode on: publish qBittorrent via Gluetun
    healthcheck:
      test: ["CMD", "gluetun", "healthcheck"]
      interval: 1m
      timeout: 10s
      retries: 3

  qbittorrent:
    image: ${QBITTORRENT_IMAGE}
    container_name: qbittorrent
    profiles:
      - "ipdirect"
    network_mode: "service:gluetun"
    environment:
      PUID: "${PUID}"
      PGID: "${PGID}"
      TZ: "${TIMEZONE}"
      LANG: "en_US.UTF-8"
      QBT_INT_PORT: "${QBT_INT_PORT}"
      QBT_BIND_ADDR: "${QBT_BIND_ADDR}"
      QBT_ENFORCE_WEBUI: "${QBT_ENFORCE_WEBUI}"
      QBT_USER: "${QBT_USER}"
      QBT_PASS: "${QBT_PASS}"
    volumes:
      - "${ARR_DOCKER_DIR}/qbittorrent:/config"
      - "${DOWNLOADS_DIR}:/downloads"
      - "${COMPLETED_DIR}:/completed"
      - "${ARR_STACK_DIR}/scripts/qbt-helper.sh:/custom-cont-init.d/00-qbt-webui:ro"
    depends_on:
      gluetun:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "/custom-cont-init.d/00-qbt-webui", "healthcheck"]
      interval: 30s
      timeout: 10s
      retries: 3

  sonarr:
    image: ${SONARR_IMAGE}
    container_name: sonarr
    profiles:
      - "ipdirect"
    networks:
      - arr_net
    depends_on:
      gluetun:
        condition: service_healthy
      qbittorrent:
        condition: service_started
    environment:
      PUID: "${PUID}"
      PGID: "${PGID}"
      TZ: "${TIMEZONE}"
      LANG: "en_US.UTF-8"
    volumes:
      - "${ARR_DOCKER_DIR}/sonarr:/config"
      - "${DOWNLOADS_DIR}:/downloads"
      - "${COMPLETED_DIR}:/completed"
      - "${TV_DIR}:/tv"
    # Arr LAN exposure happens only when EXPOSE_DIRECT_PORTS=1
    # ports:
    #   - "${LAN_IP}:${SONARR_PORT}:${SONARR_INT_PORT}"

networks:
  arr_net:
    driver: bridge

volumes:
  gluetun_state:
    driver: local
```

**Notes:**
- All Arr services and Gluetun attach to `arr_net`, so Docker DNS resolves the hostname `gluetun`. Arr apps test qBittorrent at `http://gluetun:${QBT_INT_PORT}` even though they live on the LAN bridge.
- qBittorrent inherits Gluetun’s namespace, so publish WebUI and BitTorrent ports on the **gluetun** service only. Arr LAN ports remain commented out unless `EXPOSE_DIRECT_PORTS=1`.
- Keep `${COMPLETED_DIR}` as the qBittorrent "Completed" folder so Arr imports without Remote Path Mapping.
- Radarr, Lidarr, and Prowlarr follow the same pattern as Sonarr with `${ARR_DOCKER_DIR}/<service>` config mounts plus `${MOVIES_DIR}`/`${MUSIC_DIR}` as appropriate.

## B) Split-mode OFF (`SPLIT_VPN=0`, everything inside Gluetun)

```yaml
version: "3.8"

services:
  gluetun:
    image: ${GLUETUN_IMAGE}
    container_name: gluetun
    profiles:
      - "ipdirect"
    cap_add:
      - NET_ADMIN
    devices:
      - /dev/net/tun
    environment:
      VPN_SERVICE_PROVIDER: "${VPN_SERVICE_PROVIDER}"
      VPN_TYPE: "${VPN_TYPE}"
      GLUETUN_FIREWALL_INPUT_PORTS: "${GLUETUN_FIREWALL_INPUT_PORTS}"   # Optional provider port-forward lease range
      GLUETUN_FIREWALL_OUTBOUND_SUBNETS: "${GLUETUN_FIREWALL_OUTBOUND_SUBNETS}"
      HTTP_CONTROL_SERVER_ADDRESS: ":${GLUETUN_CONTROL_PORT}"
      HTTP_CONTROL_SERVER_AUTH: "apikey"
      HTTP_CONTROL_SERVER_APIKEY: "${GLUETUN_API_KEY}"
      VPN_PORT_FORWARDING: "on"
      VPN_PORT_FORWARDING_PROVIDER: "protonvpn"
      VPN_PORT_FORWARDING_STATUS_FILE: "/tmp/gluetun/forwarded_port"
      VPN_PORT_FORWARDING_UP_COMMAND: "/scripts/vpn-port-guard-hook.sh up"
      VPN_PORT_FORWARDING_DOWN_COMMAND: "/scripts/vpn-port-guard-hook.sh down"
      QBT_USER: "${QBT_USER}"
      QBT_PASS: "${QBT_PASS}"
      QBITTORRENT_ADDR: "http://${LOCALHOST_IP}:${QBT_INT_PORT}"
      TZ: "${TIMEZONE}"
    volumes:
      - "${ARR_DOCKER_DIR}/gluetun:/gluetun"
      - "gluetun_state:/tmp/gluetun"
      - "gluetun_state:/gluetun_state"
      - "${ARR_STACK_DIR}/scripts:/scripts:ro"
    ports:
      - "127.0.0.1:${GLUETUN_CONTROL_PORT}:${GLUETUN_CONTROL_PORT}"
      - "${LAN_IP}:${QBT_PORT}:${QBT_INT_PORT}"
      - "${LAN_IP}:${SONARR_PORT}:${SONARR_INT_PORT}"
      - "${LAN_IP}:${RADARR_PORT}:${RADARR_INT_PORT}"
      - "${LAN_IP}:${LIDARR_PORT}:${LIDARR_INT_PORT}"
      - "${LAN_IP}:${PROWLARR_PORT}:${PROWLARR_INT_PORT}"
    healthcheck:
      test: ["CMD", "gluetun", "healthcheck"]
      interval: 1m
      timeout: 10s
      retries: 3

  qbittorrent:
    image: ${QBITTORRENT_IMAGE}
    container_name: qbittorrent
    profiles:
      - "ipdirect"
    network_mode: "service:gluetun"
    environment:
      PUID: "${PUID}"
      PGID: "${PGID}"
      TZ: "${TIMEZONE}"
      LANG: "en_US.UTF-8"
      QBT_INT_PORT: "${QBT_INT_PORT}"
      QBT_BIND_ADDR: "${QBT_BIND_ADDR}"
      QBT_ENFORCE_WEBUI: "${QBT_ENFORCE_WEBUI}"
      QBT_USER: "${QBT_USER}"
      QBT_PASS: "${QBT_PASS}"
    volumes:
      - "${ARR_DOCKER_DIR}/qbittorrent:/config"
      - "${DOWNLOADS_DIR}:/downloads"
      - "${COMPLETED_DIR}:/completed"
      - "${ARR_STACK_DIR}/scripts/qbt-helper.sh:/custom-cont-init.d/00-qbt-webui:ro"
    depends_on:
      gluetun:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "/custom-cont-init.d/00-qbt-webui", "healthcheck"]
      interval: 30s
      timeout: 10s
      retries: 3

  sonarr:
    image: ${SONARR_IMAGE}
    container_name: sonarr
    profiles:
      - "ipdirect"
    network_mode: "service:gluetun"
    depends_on:
      gluetun:
        condition: service_healthy
      qbittorrent:
        condition: service_started
    environment:
      PUID: "${PUID}"
      PGID: "${PGID}"
      TZ: "${TIMEZONE}"
      LANG: "en_US.UTF-8"
    volumes:
      - "${ARR_DOCKER_DIR}/sonarr:/config"
      - "${DOWNLOADS_DIR}:/downloads"
      - "${COMPLETED_DIR}:/completed"
      - "${TV_DIR}:/tv"

volumes:
  gluetun_state:
    driver: local
```

**Notes:**
- Every container shares Gluetun’s namespace, so **only** Gluetun publishes ports to the LAN. Remove unwanted ports to reduce exposure.
- Arr apps continue to connect to qBittorrent via `http://gluetun:${QBT_INT_PORT}` because Docker DNS resolves the `gluetun` hostname internally.
- When you need provider port forwarding, configure it on Gluetun (for example by setting `GLUETUN_FIREWALL_INPUT_PORTS`). This differs from Docker port mappings, which remain in the `ports:` section.
- Radarr, Lidarr, and Prowlarr reuse the same structure as Sonarr with service-specific library mounts under `${ARR_DATA_ROOT}`.

## Arr app download client configuration

Use the same host/port in every Arr app:

| Setting | Value |
| --- | --- |
| Host | `gluetun` |
| Port | `${QBT_INT_PORT}` (or whatever WebUI port you mapped on Gluetun) |
| Username | `${QBT_USER}` |
| Password | `${QBT_PASS}` |
| Category | `tv`, `movies`, `music` (optional) |
| Enable SSL | Off unless you terminate TLS elsewhere |

Example payload for Sonarr (`Settings → Download Clients → qBittorrent → Test`):

```json
{
  "name": "qBittorrent",
  "enable": true,
  "host": "gluetun",
  "port": ${QBT_INT_PORT},
  "urlBase": "",
  "username": "${QBT_USER}",
  "password": "${QBT_PASS}",
  "category": "tv",
  "initialState": 0
}
```

Repeat with the same host/port in Radarr, Prowlarr, and Lidarr so they all reuse the credentials.

## Connectivity checklist (inside containers)

```bash
# 1. Confirm Docker DNS resolves the Gluetun hostname
# (run from any Arr container, e.g. Sonarr)
docker compose exec sonarr getent hosts gluetun

# 2. Verify qBittorrent WebUI responds without touching the WAN
# Use the internal hostname and port published on Gluetun
docker compose exec sonarr curl -fsS http://gluetun:${QBT_INT_PORT}/api/v2/app/version

# 3. If the curl fails, ensure the Arr service shares the same network namespace
# Split-mode ON: check that gluetun and the Arr app both list arr_net
docker network inspect arr_net --format '{{json .Containers}}'

# Split-mode OFF: confirm every service uses Gluetun's namespace
# (no dedicated networks, no host ports outside Gluetun)
docker compose config --services | xargs -I{} docker inspect {} --format '{{.Name}} -> {{.HostConfig.NetworkMode}}'
```

If these commands succeed, Arr apps can reach qBittorrent without exposing the WebUI to the WAN. When they fail, check: (1) Gluetun health, (2) ports published on Gluetun, (3) WebUI bound to `0.0.0.0`, (4) `${DOWNLOADS_DIR}`/`${COMPLETED_DIR}` permissions, and (5) credentials.

## Switching safely between modes

1. Stop the stack: `docker compose down` from `${ARR_STACK_DIR}`.
2. Edit `${ARRCONF_DIR}/userr.conf` and toggle `SPLIT_VPN=1` (split mode) or `SPLIT_VPN=0` (full-tunnel). Adjust `EXPOSE_DIRECT_PORTS` if you want LAN port exposure.
3. Rerun `./arr.sh --yes` so the installer regenerates `.env` and `docker-compose.yml`.
4. Recreate the stack: `docker compose up -d`.
5. Re-test the download client entries in each Arr app. They should continue to resolve `http://gluetun:${QBT_INT_PORT}` without edits.
6. When exposing ports to the LAN, review firewall rules and Gluetun VPN status so the WebUI does not fall back to the WAN.
